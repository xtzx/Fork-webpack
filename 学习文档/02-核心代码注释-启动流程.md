# Webpack 核心代码注释 - 启动流程

> 本文档配合已添加注释的源码文件阅读

## 📁 已添加注释的文件

### ✅ 第一批：启动入口（已完成）

1. **bin/webpack.js** - 命令行入口
2. **lib/webpack.js** - 核心工厂函数
3. **lib/index.js** - 主导出文件（下一步）

---

## 一、命令行启动流程（bin/webpack.js）

### 1.1 文件职责

**核心任务**：检查并加载 webpack-cli

**设计哲学**：
- webpack 核心 = 编译引擎（纯 API）
- webpack-cli = 命令行界面（独立包）
- 分离的好处：
  - 核心更精简
  - CLI 可以独立更新
  - 可以有多个 CLI 实现（如 webpack-command）

### 1.2 执行流程图

```
用户执行: webpack
    ↓
bin/webpack.js 启动
    ↓
检查 webpack-cli 是否安装？
    ├─ 是 → 直接运行 CLI
    │        ↓
    │   根据 package.json type 判断
    │        ├─ ESM: import()
    │        └─ CommonJS: require()
    │
    └─ 否 → 询问用户是否安装
            ├─ 否 → 退出
            └─ 是 → 自动安装
                    ↓
                检测包管理器
                ├─ yarn.lock → yarn add -D
                ├─ pnpm-lock.yaml → pnpm install -D
                └─ 默认 → npm install -D
                    ↓
                安装成功后运行 CLI
```

### 1.3 关键知识点

#### 1. 包管理器自动检测

```javascript
// 通过 lock 文件判断使用哪个包管理器
if (fs.existsSync(path.resolve(process.cwd(), "yarn.lock"))) {
    packageManager = "yarn";
} else if (fs.existsSync(path.resolve(process.cwd(), "pnpm-lock.yaml"))) {
    packageManager = "pnpm";
} else {
    packageManager = "npm"; // 默认
}
```

**为什么这样设计**：
- 尊重用户的包管理器选择
- 避免 lock 文件冲突
- 提供更好的用户体验

#### 2. ESM 与 CommonJS 兼容

```javascript
if (pkg.type === "module" || /\.mjs/i.test(pkg.bin[cli.binName])) {
    // ESM: 使用动态 import
    import(path.resolve(path.dirname(pkgPath), pkg.bin[cli.binName]));
} else {
    // CommonJS: 使用 require
    require(path.resolve(path.dirname(pkgPath), pkg.bin[cli.binName]));
}
```

**判断依据**：
1. `package.json` 中 `type: "module"`
2. 或者入口文件扩展名是 `.mjs`

#### 3. Yarn PnP 支持

```javascript
if (process.versions.pnp) {
    return true; // PnP 模式下认为已安装
}
```

**什么是 Yarn PnP**：
- Plug'n'Play：Yarn 2+ 的依赖管理方式
- 不使用 `node_modules`，直接从缓存加载
- 通过 `.pnp.js` 文件管理依赖关系
- 安装速度更快，磁盘占用更少

#### 4. 退出码处理技巧

```javascript
// 预设为失败
process.exitCode = 1;

questionInterface.question(question, answer => {
    if (normalizedAnswer) {
        // 用户同意，重置为成功
        process.exitCode = 0;
        // ... 执行安装
    }
    // 如果用户拒绝，保持 exitCode = 1
});
```

**为什么这样设计**：
- 处理非终端环境（如 CI）下回调可能不执行的情况
- 确保异常情况下进程退出码正确

---

## 二、核心工厂函数（lib/webpack.js）

### 2.1 文件职责

**核心任务**：创建 Compiler 实例

这是 webpack 初始化的**最核心流程**，每个步骤都有严格的顺序！

### 2.2 完整初始化流程

```javascript
const createCompiler = rawOptions => {
    // 1. 规范化配置
    const options = getNormalizedWebpackOptions(rawOptions);

    // 2. 应用基础默认值
    applyWebpackOptionsBaseDefaults(options);

    // 3. 创建 Compiler
    const compiler = new Compiler(options.context, options);

    // 4. 应用 Node 环境插件
    new NodeEnvironmentPlugin({...}).apply(compiler);

    // 5. 注册用户插件
    for (const plugin of options.plugins) {
        plugin.apply(compiler);
    }

    // 6. 应用完整默认值
    applyWebpackOptionsDefaults(options);

    // 7. 触发环境钩子
    compiler.hooks.environment.call();
    compiler.hooks.afterEnvironment.call();

    // 8. 应用内置插件
    new WebpackOptionsApply().process(options, compiler);

    // 9. 触发初始化钩子
    compiler.hooks.initialize.call();

    return compiler;
};
```

### 2.3 为什么顺序如此重要？

#### 问题：为什么用户插件在"应用完整默认值"之前注册？

```javascript
// 步骤5: 注册用户插件
for (const plugin of options.plugins) {
    plugin.apply(compiler);
}

// 步骤6: 应用完整默认值（在用户插件之后）
applyWebpackOptionsDefaults(options);
```

**答案**：
1. 用户插件可能需要读取配置项
2. 如果配置项为 `undefined`，会使用默认值
3. 这样用户插件可以通过 `undefined` 判断用户是否显式配置
4. 默认值应该在用户插件有机会影响配置之后再应用

**举例**：
```javascript
class MyPlugin {
    apply(compiler) {
        // 此时 compiler.options.mode 可能是 undefined
        if (compiler.options.mode === undefined) {
            // 用户没有设置 mode，使用自定义逻辑
            compiler.options.mode = 'custom';
        }
    }
}

// 步骤6: 应用默认值
// 如果 mode 仍是 undefined，才设置为 'production'
```

#### 问题：为什么有两次默认值应用？

```javascript
// 步骤2: 基础默认值
applyWebpackOptionsBaseDefaults(options);

// 步骤6: 完整默认值
applyWebpackOptionsDefaults(options);
```

**答案**：

**基础默认值**（步骤2）：
- 只设置必需的基础配置
- 例如：`context`（工作目录）
- 这些是创建 Compiler 必需的

**完整默认值**（步骤6）：
- 根据已有配置推断其他配置
- 例如：根据 `mode` 推断优化配置
- 需要考虑用户插件的影响

### 2.4 配置验证的两阶段策略

```javascript
// 阶段1: 快速检查（预编译的 schema）
if (!asArray(options).every(webpackOptionsSchemaCheck)) {
    // 阶段2: 详细检查（完整的 schema）
    getValidateSchema()(webpackOptionsSchema, options);
}
```

**性能优化**：
- 预编译的 schema 检查速度快（纯 JS 代码）
- 完整的 schema 检查慢（需要解析 JSON schema）
- 90% 的配置都能通过快速检查
- 只有配置错误时才使用慢速但详细的检查

### 2.5 同步调用 vs 异步调用

#### 同步调用（返回 compiler）

```javascript
const compiler = webpack(config);
compiler.run((err, stats) => {
    // 手动控制编译
});
```

**适用场景**：
- 需要精确控制编译时机
- 需要访问 compiler API
- 自定义构建脚本

#### 异步调用（自动执行）

```javascript
webpack(config, (err, stats) => {
    // 自动执行编译
});
```

**适用场景**：
- 简单的一次性编译
- webpack-cli 内部使用
- 脚本化场景

**关键差异**：
```javascript
if (callback) {
    // 异步调用：自动 run 并 close
    compiler.run((err, stats) => {
        compiler.close(err2 => {
            callback(err || err2, stats);
        });
    });
} else {
    // 同步调用：返回 compiler，由用户控制
    return compiler;
}
```

### 2.6 资源清理的重要性

```javascript
compiler.run((err, stats) => {
    // ⚠️ 重要：必须调用 close 释放资源
    compiler.close(err2 => {
        callback(err || err2, stats);
    });
});
```

**为什么必须 close**：
1. 关闭文件监听器（watchpack）
2. 释放缓存资源
3. 关闭 worker 线程
4. 清理临时文件

**不 close 的后果**：
- 内存泄漏
- 进程无法退出
- 文件句柄泄漏

---

## 三、关键设计模式

### 3.1 工厂模式

```javascript
// 不直接 new Compiler，而是通过工厂函数
const createCompiler = (options) => {
    // 复杂的初始化逻辑
    const compiler = new Compiler(...);
    // 配置和插件注册
    return compiler;
};
```

**优点**：
- 封装复杂的创建逻辑
- 统一的初始化流程
- 便于测试和扩展

### 3.2 插件模式

```javascript
// 所有插件都遵循相同接口
class MyPlugin {
    apply(compiler) {
        compiler.hooks.someHook.tap('MyPlugin', () => {
            // 插件逻辑
        });
    }
}

// 统一的注册方式
plugin.apply(compiler);
```

**优点**：
- 高度可扩展
- 核心功能也是插件
- 用户插件和内置插件一视同仁

### 3.3 懒加载 + 记忆化

```javascript
const getValidateSchema = memoize(() => require("./validateSchema"));
```

**优点**：
- 首次调用时才加载模块
- 结果会被缓存
- 减少启动时间和内存占用

---

## 四、实战技巧

### 4.1 调试 webpack 初始化

在以下位置设置断点：

```javascript
// lib/webpack.js
const createCompiler = rawOptions => {
    // 断点1: 查看原始配置
    debugger;

    const options = getNormalizedWebpackOptions(rawOptions);
    // 断点2: 查看规范化后的配置
    debugger;

    applyWebpackOptionsDefaults(options);
    // 断点3: 查看应用默认值后的配置
    debugger;

    new WebpackOptionsApply().process(options, compiler);
    // 断点4: 查看注册了哪些内置插件
    debugger;

    return compiler;
};
```

### 4.2 查看注册了哪些插件

```javascript
const webpack = require('webpack');
const config = require('./webpack.config.js');

const compiler = webpack(config);

// 查看所有注册的钩子和插件
console.log('Registered hooks:');
for (const hookName in compiler.hooks) {
    const hook = compiler.hooks[hookName];
    if (hook.taps && hook.taps.length > 0) {
        console.log(`${hookName}:`, hook.taps.map(t => t.name));
    }
}
```

### 4.3 自定义插件执行顺序

```javascript
// 插件注册顺序很重要！
module.exports = {
    plugins: [
        // 先注册的插件先执行（在同一个钩子上）
        new PluginA(),
        new PluginB(),
    ]
};
```

---

## 五、常见误区

### ❌ 误区1：配置在 createCompiler 内部会被修改

**错误理解**：传入的配置对象会被修改

**实际情况**：
```javascript
const options = getNormalizedWebpackOptions(rawOptions);
// options 是一个新对象，不会修改 rawOptions
```

配置会被**深拷贝并规范化**，原始配置不受影响。

### ❌ 误区2：watch 模式不需要 callback

**错误代码**：
```javascript
webpack({ watch: true }); // ⚠️ 警告！
```

**正确代码**：
```javascript
webpack({ watch: true }, (err, stats) => {
    // watch 模式必须提供 callback
});
```

**原因**：watch 模式需要持续回调，没有 callback 无法获取编译结果。

### ❌ 误区3：不调用 compiler.close()

**错误代码**：
```javascript
compiler.run((err, stats) => {
    console.log('Done!');
    // 忘记调用 close()
});
```

**后果**：
- 进程不会退出
- 内存泄漏
- 文件监听器未关闭

---

## 六、性能优化要点

从源码中学到的优化技巧：

### 1. 懒加载模块

```javascript
// ❌ 不好：启动时就加载所有模块
const validateSchema = require("./validateSchema");

// ✅ 好：需要时才加载
const getValidateSchema = memoize(() => require("./validateSchema"));
```

### 2. 预编译 Schema

```javascript
// 预编译的 schema 检查（快）
webpackOptionsSchemaCheck(options);

// 完整的 schema 检查（慢，仅在错误时使用）
validateSchema(webpackOptionsSchema, options);
```

### 3. 减少重复计算

```javascript
// 使用 memoize 缓存函数结果
const memoize = require("./util/memoize");
const expensiveFunction = memoize(() => {
    // 昂贵的计算
});
```

---

## 七、下一步学习

已完成的文件：
- ✅ bin/webpack.js
- ✅ lib/webpack.js

下一步计划：
1. lib/index.js - 导出机制
2. lib/Compiler.js - 编译器主类（重点！）
3. lib/Compilation.js - 编译实例（重点！）
4. lib/Module.js & lib/NormalModule.js - 模块系统

---

## 八、快速参考

### webpack() 函数签名

```typescript
function webpack(
    options: WebpackOptions | WebpackOptions[],
    callback?: (err: Error, stats: Stats) => void
): Compiler | MultiCompiler;
```

### createCompiler 流程记忆口诀

**"规基创环用，完境内初"**

1. **规**范化配置
2. **基**础默认值
3. **创**建 Compiler
4. **环**境插件（Node）
5. **用**户插件
6. **完**整默认值
7. **境**（环境）钩子
8. **内**置插件
9. **初**始化钩子

### 关键钩子顺序

```
environment → afterEnvironment → initialize
```

这是 compiler 创建后立即触发的三个钩子。
