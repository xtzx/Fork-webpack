# 依赖图构建原理 - 可视化流程图

> 通过流程图完全理解 ModuleGraph 的构建过程

## 📋 图表目录

1. [主流程图 - 依赖图构建概览](#图表-1主流程图---依赖图构建概览)
2. [详细流程 - 入口处理](#图表-2详细流程---入口处理)
3. [详细流程 - 模块创建](#图表-3详细流程---模块创建)
4. [详细流程 - 模块构建与AST解析](#图表-4详细流程---模块构建与ast解析)
5. [详细流程 - 建立图连接](#图表-5详细流程---建立图连接)
6. [详细流程 - 依赖处理与递归](#图表-6详细流程---依赖处理与递归)
7. [数据结构关系图](#图表-7数据结构关系图)
8. [Tree Shaking 应用流程](#图表-8tree-shaking-应用流程)

---

## 图表 1：主流程图 - 依赖图构建概览

> 从 addEntry 到 ModuleGraph 完成的整体流程

```mermaid
graph TD
    Start([开始: webpack config]) --> Init[创建 Compiler<br/>创建 Compilation]
    Init --> MakeStart[触发 make 钩子<br/>compiler.hooks.make]

    MakeStart --> Step1[步骤1: 添加入口<br/>compilation.addEntry]

    Step1 --> Step2[步骤2: 创建入口模块<br/>factorizeModule]
    Step2 --> Factory[NormalModuleFactory.create<br/>解析路径 + 匹配loader]
    Factory --> CreateModule[new NormalModule]

    CreateModule --> Step3[步骤3: 添加模块<br/>addModule - 去重检查]
    Step3 --> Exists{模块已存在?}
    Exists -->|是| UseExisting[复用现有模块]
    Exists -->|否| AddNew[添加到 modules 集合]

    UseExisting --> Step4
    AddNew --> Step4[步骤4: 构建模块<br/>buildModule]

    Step4 --> Build[module.build<br/>详见图表4]
    Build --> CollectDeps[收集依赖<br/>module.dependencies]

    CollectDeps --> Step5[步骤5: 建立图连接<br/>setResolvedModule<br/>详见图表5]

    Step5 --> ConnectDone[双向连接建立<br/>incoming + outgoing]

    ConnectDone --> Step6[步骤6: 处理依赖<br/>processModuleDependencies<br/>详见图表6]

    Step6 --> HasMore{还有未处理<br/>的依赖?}
    HasMore -->|是| Recursive[递归: handleModuleCreation<br/>回到步骤2]
    Recursive --> Step2

    HasMore -->|否| Complete[完成: ModuleGraph 构建完成]

    Complete --> GraphReady[✅ 包含:<br/>- 所有模块<br/>- 所有依赖关系<br/>- 导入导出信息<br/>- 模块深度]

    GraphReady --> SealStart[进入 Seal 阶段]

    style Step5 fill:#ff9999
    style Step6 fill:#ff9999
    style GraphReady fill:#99ff99
```

---

## 图表 2：详细流程 - 入口处理

> addEntry 的详细步骤

```mermaid
graph TD
    Start([compilation.addEntry]) --> Extract[提取参数<br/>context, entry, options]

    Extract --> Normalize[规范化选项<br/>options = object or name]

    Normalize --> Call_addEntryItem[调用 _addEntryItem]

    Call_addEntryItem --> GetEntry{获取入口数据<br/>entryData}

    GetEntry -->|不存在| CreateNew[创建新入口数据<br/>entryData = {<br/>  dependencies: [],<br/>  includeDeps: [],<br/>  options: {...}<br/>}]

    GetEntry -->|已存在| MergeOptions[合并选项<br/>处理冲突]

    CreateNew --> AddDep
    MergeOptions --> CheckConflict{选项冲突?}
    CheckConflict -->|是| Error[抛出错误<br/>Conflicting options]
    CheckConflict -->|否| AddDep[添加依赖到列表<br/>entryData.dependencies]

    AddDep --> SaveEntry[保存到 entries Map<br/>entries.set name, entryData]

    SaveEntry --> HookAdd[触发 addEntry 钩子]

    HookAdd --> CallTree[调用 addModuleTree<br/>开始构建模块树]

    CallTree --> ValidateDep{验证依赖对象}
    ValidateDep -->|无效| ErrorDep[错误: 无效依赖]
    ValidateDep -->|有效| GetFactory[获取模块工厂<br/>dependencyFactories.get]

    GetFactory --> FactoryExists{工厂存在?}
    FactoryExists -->|否| ErrorFactory[错误: 无工厂]
    FactoryExists -->|是| CallCreate[调用 handleModuleCreation<br/>进入图表3]

    CallCreate --> Success[成功回调<br/>succeedEntry 钩子]
    Success --> End([完成])

    Error --> End
    ErrorDep --> End
    ErrorFactory --> End

    style CallTree fill:#ffcc99
    style CallCreate fill:#99ccff
```

---

## 图表 3：详细流程 - 模块创建

> handleModuleCreation 的核心逻辑

```mermaid
graph TD
    Start([handleModuleCreation]) --> Profile[启动性能分析<br/>if profile enabled]

    Profile --> Factorize[factorizeModule<br/>创建模块实例]

    Factorize --> FactoryCreate[factory.create<br/>详细流程:]
    FactoryCreate --> Resolve[resolve 路径<br/>./a.js → /path/to/a.js]
    Resolve --> MatchLoader[匹配 loader 规则<br/>test: /\.js$/ → babel-loader]
    MatchLoader --> NewModule[new NormalModule<br/>包含 loaders, parser, generator]

    NewModule --> FactoryResult{工厂结果}
    FactoryResult -->|错误| HandleError[处理错误<br/>ModuleNotFoundError]
    FactoryResult -->|成功| HasModule{返回模块?}

    HasModule -->|否| CollectDeps[收集文件依赖<br/>fileDependencies]
    CollectDeps --> ReturnNull[返回 null]

    HasModule -->|是| SetProfile[设置性能分析]
    SetProfile --> AddModule[addModule<br/>添加到编译]

    AddModule --> CheckExist{模块已存在?}
    CheckExist -->|是| ReturnExist[返回现有模块<br/>去重机制 ⭐]
    CheckExist -->|否| TryCache[尝试从缓存恢复<br/>_modulesCache.get]

    TryCache --> HasCache{有缓存?}
    HasCache -->|是| MergeCache[合并缓存模块<br/>updateCacheModule]
    HasCache -->|否| UseNew[使用新模块]

    MergeCache --> AddToSet
    UseNew --> AddToSet[添加到 modules 集合]

    AddToSet --> BuildConnect[建立图连接<br/>setResolvedModule<br/>详见图表5 ⭐⭐⭐]
    ReturnExist --> BuildConnect

    BuildConnect --> SetIssuer[设置引入者<br/>moduleGraph.setIssuerIfUnset]

    SetIssuer --> HandleBuild[_handleModuleBuildAndDependencies<br/>构建和依赖处理]

    HandleBuild --> End([返回模块])
    HandleError --> End
    ReturnNull --> End

    style BuildConnect fill:#ff9999
    style CheckExist fill:#ffcc99
```

---

## 图表 4：详细流程 - 模块构建与AST解析

> module.build() 和 parser.parse() 的详细过程

```mermaid
graph TD
    Start([module.build]) --> Reset[重置模块状态<br/>清空 dependencies<br/>清空 errors/warnings]

    Reset --> InitBuild[初始化 buildInfo<br/>buildMeta = {}]

    InitBuild --> DoBuild[_doBuild<br/>执行 loader]

    DoBuild --> CreateContext[创建 loaderContext<br/>提供 loader API]
    CreateContext --> RunLoaders[runLoaders<br/>loader-runner]

    RunLoaders --> Pitching[Pitching 阶段<br/>从左到右]
    Pitching --> ReadFile[读取源文件<br/>fs.readFile]
    ReadFile --> Normal[Normal 阶段<br/>从右到左]

    Normal --> Loader3[loader3 source]
    Loader3 --> Loader2[loader2 transformed]
    Loader2 --> Loader1[loader1 final]

    Loader1 --> CreateSource[创建 Source 对象<br/>RawSource / SourceMapSource]

    CreateSource --> CheckAST{loader 返回<br/>预解析 AST?}
    CheckAST -->|是| UseAST[使用 loader 的 AST<br/>跳过 parse]
    CheckAST -->|否| NeedParse[需要解析]

    NeedParse --> Parse[parser.parse<br/>JavascriptParser]

    Parse --> AcornParse[acorn.parse<br/>生成 AST]
    AcornParse --> DetectMode[第1轮: detectMode<br/>检测严格模式]
    DetectMode --> PreWalk[第2轮: preWalkStatements<br/>收集声明]
    PreWalk --> BlockPreWalk[第3轮: blockPreWalkStatements<br/>块级作用域]
    BlockPreWalk --> Walk[第4轮: walkStatements<br/>识别依赖 ⭐⭐⭐]

    Walk --> ImportStmt{遇到 import?}
    ImportStmt -->|是| CreateHarmony[创建 HarmonyImportDependency<br/>添加到 dependencies]

    Walk --> RequireCall{遇到 require?}
    RequireCall -->|是| CreateCommonJs[创建 CommonJsRequireDependency<br/>添加到 dependencies]

    Walk --> ImportCall{遇到 import?}
    ImportCall -->|是| CreateImport[创建 ImportDependency<br/>+ AsyncDependenciesBlock<br/>添加到 blocks]

    Walk --> ExportStmt{遇到 export?}
    ExportStmt -->|是| CreateExport[创建 HarmonyExportDependency<br/>记录导出信息]

    CreateHarmony --> DepsCollected
    CreateCommonJs --> DepsCollected
    CreateImport --> DepsCollected
    CreateExport --> DepsCollected
    UseAST --> DepsCollected

    DepsCollected[依赖收集完成<br/>module.dependencies]

    DepsCollected --> SortDeps[排序依赖<br/>按源码位置]
    SortDeps --> InitHash[生成 buildHash]
    InitHash --> CreateSnapshot[创建文件快照<br/>用于 watch 模式]

    CreateSnapshot --> End([构建完成<br/>返回 module])

    style Walk fill:#ff9999
    style CreateImport fill:#ffcc99
```

---

## 图表 5：详细流程 - 建立图连接

> setResolvedModule 的详细实现（依赖图构建的核心！）

```mermaid
graph TD
    Start([setResolvedModule<br/>origin, dependency, target]) --> CreateConn[创建连接对象<br/>new ModuleGraphConnection]

    CreateConn --> SetProps[设置连接属性<br/>originModule: origin<br/>dependency: dep<br/>module: target<br/>weak: dep.weak]

    SetProps --> GetTarget[获取目标模块的图节点<br/>targetMgm = _getModuleGraphModule target]

    GetTarget --> TargetExists{节点存在?}
    TargetExists -->|否| CreateTarget[创建新节点<br/>new ModuleGraphModule<br/>保存到 _moduleMap]
    TargetExists -->|是| UseTarget[使用现有节点]

    CreateTarget --> AddIncoming
    UseTarget --> AddIncoming[添加到入边 ⭐<br/>targetMgm.incomingConnections<br/>.add connection]

    AddIncoming --> TargetKnows[✅ 目标模块现在知道<br/>origin 依赖它]

    TargetKnows --> HasOrigin{有源模块?}

    HasOrigin -->|否| MapDep[入口依赖<br/>_dependencyMap.set<br/>dependency, connection]

    HasOrigin -->|是| GetOrigin[获取源模块的图节点<br/>originMgm = _getModuleGraphModule origin]

    GetOrigin --> OriginExists{节点存在?}
    OriginExists -->|否| CreateOrigin[创建新节点]
    OriginExists -->|是| UseOrigin[使用现有节点]

    CreateOrigin --> CheckOutgoing
    UseOrigin --> CheckOutgoing{outgoing<br/>存在?}

    CheckOutgoing -->|否| CreateOut[懒创建<br/>outgoing = new SortableSet]
    CheckOutgoing -->|是| UseOut[使用现有]

    CreateOut --> AddOutgoing
    UseOut --> AddOutgoing[添加到出边 ⭐<br/>originMgm.outgoingConnections<br/>.add connection]

    AddOutgoing --> OriginKnows[✅ 源模块现在知道<br/>它依赖 target]

    OriginKnows --> AddUnassigned[添加到未分配列表<br/>_unassignedConnections]

    AddUnassigned --> Done
    MapDep --> Done([完成<br/>图连接建立 ✅])

    Done --> Result[结果:<br/>双向连接建立<br/>origin.outgoing ← conn → target.incoming]

    style AddIncoming fill:#99ff99
    style AddOutgoing fill:#99ff99
    style Done fill:#ffcc99
```

---

## 图表 6：详细流程 - 依赖处理与递归

> processModuleDependencies 的递归机制

```mermaid
graph TD
    Start([processModuleDependencies<br/>module]) --> Init[初始化数据结构<br/>sortedDependencies = []<br/>dependencies = Map]

    Init --> InitCache[初始化缓存变量<br/>factoryCacheKey<br/>listCacheKey1/2]

    InitCache --> InitCounter[初始化计数器<br/>inProgressSorting = 1<br/>inProgressTransitive = 1]

    InitCounter --> StartLoop[开始遍历<br/>queue = module]

    StartLoop --> PopBlock{队列非空?}
    PopBlock -->|否| AllDone[遍历完成]
    PopBlock -->|是| GetBlock[block = queue.pop]

    GetBlock --> HasDeps{block.dependencies?}
    HasDeps -->|是| LoopDeps[遍历 dependencies]
    HasDeps -->|否| CheckBlocks

    LoopDeps --> ProcessDep[processDependency<br/>设置父级引用]

    ProcessDep --> CheckCache{检查缓存}
    CheckCache -->|命中| UseCache[使用缓存模块]
    CheckCache -->|未命中| Resolve[processDependencyForResolving<br/>依赖分组]

    Resolve --> GetIdent[获取资源标识<br/>resourceIdent]
    GetIdent --> GetCategory[获取类别<br/>category = 'esm']
    GetCategory --> GetConstructor[获取构造函数<br/>HarmonyImportDependency]

    GetConstructor --> Cache1{缓存级别1<br/>构造函数相同?}
    Cache1 -->|是| SuperFast[⚡超快路径<br/>直接使用 listCacheValue]
    Cache1 -->|否| Cache2{缓存级别2<br/>工厂相同?}

    Cache2 -->|是| Fast[⚡快路径<br/>使用 factoryCacheValue]
    Cache2 -->|否| Slow[慢路径<br/>Map.get factory]

    SuperFast --> AddToGroup
    Fast --> AddToGroup
    Slow --> AddToGroup[添加到依赖组<br/>sortedDependencies.push]

    UseCache --> NextDep
    AddToGroup --> NextDep{还有依赖?}
    NextDep -->|是| LoopDeps
    NextDep -->|否| CheckBlocks

    CheckBlocks{block.blocks?}
    CheckBlocks -->|是| AddBlocks[添加嵌套块到队列]
    CheckBlocks -->|否| PopBlock
    AddBlocks --> PopBlock

    AllDone --> CallbackSort[onDependenciesSorted]

    CallbackSort --> CheckEmpty{有依赖组?}
    CheckEmpty -->|否| Finish[直接完成]
    CheckEmpty -->|是| IncreasePara[增加队列并行度]

    IncreasePara --> LoopGroups[遍历 sortedDependencies]

    LoopGroups --> CallHandle[🔄 递归调用<br/>handleModuleCreation<br/>回到图表3]

    CallHandle --> CountDown[计数器 - 1]
    CountDown --> AllComplete{所有完成?}
    AllComplete -->|否| Wait[等待...]
    AllComplete -->|是| DecreasePara[恢复队列并行度]

    DecreasePara --> Finish([完成<br/>所有依赖已处理])

    style CallHandle fill:#ff9999
    style SuperFast fill:#99ff99
    style AddToGroup fill:#ffcc99
```

---

## 图表 7：数据结构关系图

> ModuleGraph 的核心数据结构

```mermaid
graph TB
    subgraph ModuleGraph["🏛️ ModuleGraph (主类)"]
        DependencyMap["_dependencyMap<br/>WeakMap&lt;Dependency, Connection&gt;<br/>━━━━━━━━━━━<br/>dependency1 → connection1<br/>dependency2 → connection2"]

        ModuleMap["_moduleMap<br/>Map&lt;Module, ModuleGraphModule&gt;<br/>━━━━━━━━━━━<br/>module1 → mgm1<br/>module2 → mgm2"]

        MetaMap["_metaMap<br/>WeakMap (元数据)"]

        Cache["_cache<br/>WeakTupleMap (缓存)"]
    end

    subgraph MGM["📦 ModuleGraphModule (图节点)"]
        Incoming["incomingConnections<br/>SortableSet&lt;Connection&gt;<br/>━━━━━━━━━━━<br/>谁依赖我 (入边)"]

        Outgoing["outgoingConnections<br/>SortableSet&lt;Connection&gt;<br/>━━━━━━━━━━━<br/>我依赖谁 (出边)"]

        Exports["exports: ExportsInfo<br/>━━━━━━━━━━━<br/>Map&lt;导出名, ExportInfo&gt;<br/>foo: {used: true}<br/>bar: {used: false}"]

        Issuer["issuer: Module<br/>引入者"]

        Depth["depth: number<br/>模块深度"]

        Indexes["preOrderIndex<br/>postOrderIndex<br/>遍历索引"]
    end

    subgraph Conn["🔗 ModuleGraphConnection (边)"]
        Origin["originModule<br/>源模块"]

        Dep["dependency<br/>依赖对象"]

        Target["module<br/>目标模块"]

        Active["active: boolean<br/>是否激活"]

        Weak["weak: boolean<br/>是否弱依赖"]
    end

    ModuleMap -.-> MGM
    DependencyMap -.-> Conn

    Incoming -.->|包含| Conn
    Outgoing -.->|包含| Conn

    Origin -.->|引用| ModuleMap
    Target -.->|引用| ModuleMap

    style ModuleGraph fill:#e1f5ff
    style MGM fill:#fff4e1
    style Conn fill:#f0ffe1
```

---

## 图表 8：Tree Shaking 应用流程

> 如何利用依赖图实现 Tree Shaking

```mermaid
graph TD
    subgraph Make["Make 阶段 - 收集信息"]
        M1[模块 a.js 构建<br/>export const foo = 1<br/>export const bar = 2]

        M1 --> M2[parser 识别 export<br/>记录提供的导出]

        M2 --> M3[exportsInfo.setProvided<br/>foo, bar]

        M4[模块 b.js 构建<br/>import foo from './a']

        M4 --> M5[parser 识别 import<br/>记录使用的导出]

        M5 --> M6[dependency.getReferencedExports<br/>返回: foo]
    end

    subgraph Seal["Seal 阶段 - 标记使用"]
        S1[FlagDependencyUsagePlugin]

        S1 --> S2[遍历所有 dependencies<br/>获取 referencedExports]

        S2 --> S3[分析哪些导出被使用]

        S3 --> S4[更新 exportsInfo<br/>setUsed foo: true<br/>setUsed bar: false]
    end

    subgraph Gen["代码生成 - 删除未使用"]
        G1[生成 a.js 的代码]

        G1 --> G2[获取 exportsInfo]

        G2 --> G3{isUsed foo?}
        G3 -->|是| G4[生成: exports.foo = 1 ✅]

        G2 --> G5{isUsed bar?}
        G5 -->|否| G6[跳过 bar ❌<br/>不生成代码]

        G4 --> Result
        G6 --> Result[最终代码:<br/>只包含 foo<br/>━━━━━━━<br/>节省 50% 代码]
    end

    M3 -.-> S1
    M6 -.-> S2
    S4 -.-> G1

    style M3 fill:#ffcc99
    style S4 fill:#ffcc99
    style G6 fill:#ff9999
    style Result fill:#99ff99
```

---

## 图表 9：代码分割流程

> SplitChunksPlugin 如何利用依赖图

```mermaid
graph TD
    Start([SplitChunksPlugin<br/>optimizeChunks 钩子]) --> Analyze[阶段1: 分析共享<br/>遍历所有模块]

    Analyze --> GetConnections[获取 incomingConnections]

    GetConnections --> CheckShared{connections.size > 1?}
    CheckShared -->|是| AddCandidate[添加到候选模块<br/>candidates.add module]
    CheckShared -->|否| Skip1[跳过<br/>未被共享]

    AddCandidate --> Group[阶段2: 分组<br/>按 cacheGroups 配置]
    Skip1 --> NextModule1{还有模块?}
    NextModule1 -->|是| Analyze
    NextModule1 -->|否| Group

    Group --> MatchRule[遍历 cacheGroups<br/>匹配规则]

    MatchRule --> TestMatch{test 匹配?}
    TestMatch -->|是| AddGroup[添加到分组<br/>groups vendors.add module]
    TestMatch -->|否| Skip2[跳过]

    AddGroup --> NextCandidate{还有候选?}
    Skip2 --> NextCandidate
    NextCandidate -->|是| MatchRule
    NextCandidate -->|否| Filter[阶段3: 过滤<br/>应用规则]

    Filter --> CalcSize[计算分组总大小<br/>size = sum module.size]

    CalcSize --> CheckMinSize{size >= minSize?}
    CheckMinSize -->|否| Reject1[❌ 太小，不提取]
    CheckMinSize -->|是| CheckMinChunks{chunks >= minChunks?}

    CheckMinChunks -->|否| Reject2[❌ 共享不够]
    CheckMinChunks -->|是| CheckMaxReq{requests <= max?}

    CheckMaxReq -->|否| PartialExtract[⚠️ 只提取最大的几个]
    CheckMaxReq -->|是| CheckEnforce{enforce?}

    CheckEnforce -->|是| ForceCreate[✅ 强制创建<br/>忽略所有限制]
    CheckEnforce -->|否| NormalCreate[✅ 正常创建]

    PartialExtract --> Create
    ForceCreate --> Create
    NormalCreate --> Create[阶段4: 创建 Chunk<br/>addChunk groupName]

    Reject1 --> NextGroup
    Reject2 --> NextGroup

    Create --> MoveModules[移动模块到新 Chunk]

    MoveModules --> Disconnect[chunkGraph.disconnectChunkAndModule<br/>oldChunk, module]
    Disconnect --> Connect[chunkGraph.connectChunkAndModule<br/>newChunk, module]

    Connect --> NextGroup{还有分组?}
    NextGroup -->|是| Filter
    NextGroup -->|否| Done([完成<br/>新 Chunk 创建])

    Done --> Result[结果:<br/>vendors chunk: react, lodash<br/>common chunk: utils<br/>━━━━━━━<br/>减少 400KB 重复代码]

    style Create fill:#99ff99
    style MoveModules fill:#ffcc99
    style Result fill:#99ff99
```

---

## 图表 10：模块去重机制

> addModule 的去重逻辑

```mermaid
graph TD
    Start([addModule<br/>newModule]) --> GetId[获取唯一标识符<br/>identifier = module.identifier<br/>格式: type|path]

    GetId --> Example[示例:<br/>javascript/auto|/path/to/a.js]

    Example --> Lookup[查找已存在模块<br/>existing = _modules.get identifier]

    Lookup --> Exists{模块已存在?}

    Exists -->|是| ReturnExist[⭐ 返回现有模块<br/>不重复添加]

    Exists -->|否| TryCache[尝试从缓存恢复<br/>cached = _modulesCache.get identifier]

    TryCache --> HasCache{有缓存?}

    HasCache -->|是| Restore[恢复缓存模块<br/>cached.updateCacheModule newModule]
    HasCache -->|否| UseNew[使用新模块]

    Restore --> Merge[合并:<br/>工厂数据来自 newModule<br/>构建数据来自 cached]

    Merge --> UseCache[使用 cached 模块]

    UseCache --> AddMap
    UseNew --> AddMap[添加到 _modules Map<br/>添加到 modules Set]

    AddMap --> SetGraph[设置 moduleGraph 引用<br/>向后兼容]

    SetGraph --> Return([返回模块<br/>可能是 new/existing/cached])

    ReturnExist --> Scenario[场景示例:<br/>a.js import './common'<br/>b.js import './common'<br/>━━━━━━━<br/>common 只创建一次<br/>a 和 b 共享同一实例]

    style ReturnExist fill:#99ff99
    style UseCache fill:#ffcc99
    style Scenario fill:#e1f5ff
```

---

## 图表 11：循环依赖检测

> 如何检测和处理循环依赖

```mermaid
graph TD
    Start([检测循环依赖<br/>DFS 算法]) --> Init[初始化<br/>visiting = Set<br/>visited = Set<br/>cycles = []]

    Init --> StartDFS[对每个模块<br/>执行 DFS]

    StartDFS --> Visit[访问 module]

    Visit --> InVisiting{在 visiting 中?}

    InVisiting -->|是| Found[🔴 检测到环!<br/>记录循环路径]

    InVisiting -->|否| InVisited{在 visited 中?}

    InVisited -->|是| Skip[已访问<br/>跳过]

    InVisited -->|否| AddVisiting[添加到 visiting<br/>标记正在访问]

    AddVisiting --> GetOut[获取出边<br/>getOutgoingConnections]

    GetOut --> LoopOut[遍历出边<br/>for conn of connections]

    LoopOut --> RecurDFS[递归 DFS<br/>visit conn.module]

    RecurDFS --> MoreOut{还有出边?}
    MoreOut -->|是| LoopOut
    MoreOut -->|否| RemoveVisiting[从 visiting 移除]

    RemoveVisiting --> AddVisited[添加到 visited<br/>标记已完成]

    AddVisited --> NextModule{还有模块?}
    NextModule -->|是| StartDFS
    NextModule -->|否| Report

    Found --> Report[报告循环依赖<br/>Warning: a → b → c → a]

    Skip --> NextModule

    Report --> Handle[处理策略:<br/>⚠️ 警告但不阻止<br/>✅ 调整加载顺序<br/>✅ 使用延迟执行]

    Handle --> End([完成])

    style Found fill:#ff9999
    style Handle fill:#ffcc99
```

---

## 图表 12：动态导入处理

> import() 如何创建新 Chunk

```mermaid
graph TD
    subgraph Make["Make 阶段 - 识别"]
        M1[parser 解析到<br/>import './lazy.js']

        M1 --> M2[识别为 ImportExpression<br/>AST 节点类型]

        M2 --> M3[walkImportExpression]

        M3 --> M4[创建 ImportDependency<br/>标记 async: true]

        M4 --> M5[创建 AsyncDependenciesBlock<br/>包含魔法注释]

        M5 --> M6[module.blocks.push block]
    end

    subgraph Seal["Seal 阶段 - 创建 Chunk"]
        S1[buildChunkGraph<br/>遍历 module.blocks]

        S1 --> S2{遇到 AsyncBlock?}

        S2 -->|是| S3[iteratorBlock b]

        S3 --> S4{asyncChunks?}

        S4 -->|false| S5[eager 模式<br/>不创建新 chunk]

        S4 -->|true| S6[lazy 模式<br/>创建新 ChunkGroup]

        S6 --> S7[compilation.addChunkInGroup<br/>name: webpackChunkName]

        S7 --> S8[创建新 Chunk]

        S8 --> S9[建立父子关系<br/>main chunk → lazy chunk]
    end

    subgraph Gen["代码生成 - 生成加载代码"]
        G1[ImportDependency.Template]

        G1 --> G2[生成加载代码]

        G2 --> G3["__webpack_require__.e chunkId"]

        G3 --> G4[".then(__webpack_require__ moduleId)"]

        G4 --> G5[返回 Promise]
    end

    M6 -.-> S1
    S9 -.-> G1

    G5 --> Runtime[运行时行为:<br/>1. 创建 script 标签<br/>2. 加载 lazy.chunk.js<br/>3. 执行模块代码<br/>4. resolve Promise]

    style S6 fill:#99ff99
    style S8 fill:#ffcc99
    style Runtime fill:#e1f5ff
```

---

## 使用说明

### 如何阅读这些流程图

**学习路径**：
1. 先看 **图表1 - 主流程图**（整体概览）
2. 按需查看详细流程图（深入细节）
3. 理解数据结构关系图（图表7）
4. 学习应用场景（图表8-12）

**流程图说明**：
- 🔴 红色：核心步骤
- 🟢 绿色：完成/成功
- 🟡 黄色：重要节点
- ⭐ 星标：特别重要

**节点类型**：
- `[矩形]`: 处理步骤
- `{菱形}`: 判断条件
- `([圆角])`: 开始/结束
- `subgraph`: 分组/阶段

---

## 关键要点速查

### ModuleGraph 核心

```
两个核心 Map：
├─ _dependencyMap: Dependency → Connection (WeakMap)
└─ _moduleMap: Module → ModuleGraphModule (Map)

双向连接：
├─ incoming: 谁依赖我 (Tree Shaking)
└─ outgoing: 我依赖谁 (递归构建)
```

### 构建核心

```
递归三要素：
1. factorizeModule - 创建模块
2. setResolvedModule - 建立连接 ⭐⭐⭐
3. processModuleDependencies - 递归处理

去重机制：
identifier = type|path
_modules.get(identifier) → 复用已存在
```

### 性能优化

```
三级缓存：
├─ 超快路径: 99% (构造函数相同)
├─ 快路径: 0.9% (工厂相同)
└─ 慢路径: 0.1% (Map 查找)

内存优化：
├─ WeakMap: 自动 GC
├─ 懒创建: 节省 50% 内存
└─ 去重: 避免重复构建
```

---

**相关文档**：
- 05-依赖图构建原理详解.md（文字详解）
- 04-Webpack核心运行流程详解.md（完整流程）
- 08-构建阶段（Make）.md（Make 阶段）

**相关代码**（已添加详细逐行注释）：
- lib/ModuleGraph.js（80% 注释）
- lib/Compilation.js（85% 注释，核心方法 100%）
- lib/NormalModuleFactory.js（85% 注释）

