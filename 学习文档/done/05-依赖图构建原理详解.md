# Webpack 依赖图构建原理详解

> 从数据结构到算法，从概览到细节，完全理解依赖图

## 📋 目录

1. [依赖图是什么](#一依赖图是什么)
2. [核心数据结构详解](#二核心数据结构详解)
3. [关联文件和模块](#三关联文件和模块)
4. [构建流程图（概览）](#四构建流程图概览)
5. [详细流程图（分步骤）](#五详细流程图分步骤)
6. [构建算法详解](#六构建算法详解)
7. [应用场景深入](#七应用场景深入)
8. [性能优化技巧](#八性能优化技巧)

---

## 一、依赖图是什么？

### 1.1 核心概念

**ModuleGraph（模块依赖图）**是一个有向图数据结构，是 webpack 最核心的数据结构之一。

```
核心组成：
┌─────────────────────────────────────┐
│  ModuleGraph (依赖图容器)           │
│                                     │
│  ┌─────────┐         ┌───────────┐ │
│  │ Module  │ ──────→ │  Module   │ │  节点：Module（模块）
│  │ (节点)  │ 依赖关系 │  (节点)   │ │
│  └─────────┘         └───────────┘ │
│       ↑                              │
│       │                              │
│  ┌─────────┐                        │
│  │Dependency│  边：Dependency（依赖）│
│  └─────────┘                        │
│       ↓                              │
│  ┌──────────────┐                   │
│  │ Connection   │  连接信息          │
│  │ModuleGraph   │                   │
│  │Connection    │                   │
│  └──────────────┘                   │
└─────────────────────────────────────┘
```

### 1.2 三个核心类

| 类 | 作用 | 存储内容 |
|---|------|---------|
| **Module** | 模块对象 | 源码、依赖列表、构建信息 |
| **Dependency** | 依赖声明 | 请求路径、位置、类型 |
| **ModuleGraphConnection** | 依赖实现 | 源模块、目标模块、状态 |

---

## 二、核心数据结构详解

### 2.1 ModuleGraph 主类结构

```javascript
class ModuleGraph {
  // ===== 核心存储 =====

  _dependencyMap: WeakMap<Dependency, ModuleGraphConnection | null>
  /**
   * 依赖 → 连接的映射
   *
   * 【示例】
   * dependency1 → connection(entry → a.js)
   * dependency2 → connection(entry → b.js)
   * dependency3 → null（未解析）
   *
   * 【WeakMap 原因】
   * - 不阻止 Dependency 被 GC
   * - O(1) 查找
   * - 自动清理
   */

  _moduleMap: Map<Module, ModuleGraphModule>
  /**
   * 模块 → 图节点的映射
   *
   * 【示例】
   * module1 → ModuleGraphModule {
   *   incomingConnections: Set<Connection>,
   *   outgoingConnections: Set<Connection>,
   *   exports: ExportsInfo,
   *   ...
   * }
   */

  // ===== 辅助存储 =====

  _metaMap: WeakMap<any, Object>
  // 元数据映射，插件可存储自定义数据

  _cache: WeakTupleMap<any[], any>
  // 缓存系统，缓存复杂计算结果
}
```

### 2.2 ModuleGraphModule 节点结构

```javascript
class ModuleGraphModule {
  // ===== 连接信息（图的核心）⭐⭐⭐ =====

  incomingConnections: SortableSet<ModuleGraphConnection>
  /**
   * 入边：谁依赖我
   *
   * 【Tree Shaking】
   * size === 0 → 模块未被使用 → 可删除
   *
   * 【代码分割】
   * size > 1 → 模块被共享 → 提取到公共 chunk
   */

  outgoingConnections: SortableSet<ModuleGraphConnection> | undefined
  /**
   * 出边：我依赖谁（懒创建）
   *
   * 【用途】
   * - 递归构建
   * - 循环检测
   * - 模块合并
   */

  // ===== 导出信息（Tree Shaking）⭐⭐⭐ =====

  exports: ExportsInfo
  /**
   * Map<导出名, ExportInfo>
   *
   * ExportInfo {
   *   name: 'foo',
   *   used: true/false,  ← Tree Shaking 关键
   *   provided: true/false,
   *   canMangle: true/false
   * }
   */

  // ===== 引入和顺序信息 =====

  issuer: Module | null       // 引入者
  depth: number | null        // 深度（最短路径长度）
  preOrderIndex: number       // 前序索引（DFS 进入）
  postOrderIndex: number      // 后序索引（DFS 离开）

  // ===== 优化信息 =====

  optimizationBailout: string[]  // 优化失败原因
  async: boolean                  // 是否异步模块
  profile: ModuleProfile | null   // 性能数据
}
```

### 2.3 ModuleGraphConnection 连接结构

```javascript
class ModuleGraphConnection {
  originModule: Module        // 源模块（谁依赖）
  dependency: Dependency      // 依赖对象
  module: Module             // 目标模块（被依赖）

  weak: boolean              // 是否弱依赖
  conditional: boolean       // 是否条件依赖
  active: boolean           // 是否激活

  explanations: Set<string>  // 说明信息
}
```

### 2.4 数据结构可视化

```
┌──────────────────── ModuleGraph ────────────────────────┐
│                                                          │
│  _dependencyMap (WeakMap):                              │
│  ┌────────────┐         ┌──────────────┐               │
│  │ dependency │  ────→  │  Connection  │               │
│  │ import './a'│         │  entry → a   │               │
│  └────────────┘         └──────────────┘               │
│                                                          │
│  _moduleMap (Map):                                      │
│  ┌──────────┐         ┌───────────────────────┐        │
│  │ entry.js │  ────→  │ ModuleGraphModule {   │        │
│  └──────────┘         │   incoming: [],        │        │
│                        │   outgoing: [conn1,2], │        │
│                        │   exports: {...},      │        │
│                        │   depth: 0             │        │
│                        │ }                      │        │
│                        └───────────────────────┘        │
│                                                          │
│  ┌──────────┐         ┌───────────────────────┐        │
│  │  a.js    │  ────→  │ ModuleGraphModule {   │        │
│  └──────────┘         │   incoming: [conn1],   │        │
│                        │   outgoing: [conn3],   │        │
│                        │   exports: {           │        │
│                        │     foo: {used: true}, │        │
│                        │     bar: {used: false} │        │
│                        │   },                   │        │
│                        │   depth: 1             │        │
│                        │ }                      │        │
│                        └───────────────────────┘        │
└──────────────────────────────────────────────────────────┘
```

---

## 三、关联文件和模块

### 3.1 核心文件关系图

```
依赖图构建涉及的文件及其关系：

┌─────────── 控制层 ───────────┐
│                              │
│  Compiler.js                 │
│    ├─ compile()              │
│    └─ run()                  │
│         ↓ 创建               │
│  Compilation.js              │
│    ├─ addEntry()             │
│    ├─ addModuleTree()        │
│    ├─ handleModuleCreation() │
│    └─ processModuleDeps()    │
│         ↓ 使用               │
└──────────────────────────────┘

┌─────────── 工厂层 ───────────┐
│                              │
│  NormalModuleFactory.js      │
│    ├─ create()               │
│    ├─ resolve()              │
│    └─ 匹配 loader             │
│         ↓ 创建               │
└──────────────────────────────┘

┌─────────── 模块层 ───────────┐
│                              │
│  Module.js (基类)            │
│    ↓ 继承                    │
│  NormalModule.js             │
│    ├─ build()                │
│    ├─ _doBuild()             │
│    └─ codeGeneration()       │
│         ↓ 使用               │
└──────────────────────────────┘

┌─────────── 解析层 ───────────┐
│                              │
│  JavascriptParser.js         │
│    ├─ parse()                │
│    ├─ walkStatements()       │
│    └─ 创建 Dependency         │
│         ↓ 产生               │
└──────────────────────────────┘

┌──────── 依赖图层 ⭐⭐⭐ ───────┐
│                              │
│  ModuleGraph.js              │
│    ├─ setResolvedModule()    │
│    ├─ getModule()            │
│    ├─ getExportsInfo()       │
│    └─ get/setIssuer()        │
│         ↓ 管理               │
│  ModuleGraphModule.js        │
│  ModuleGraphConnection.js    │
└──────────────────────────────┘

┌───────── 依赖类型层 ─────────┐
│                              │
│  lib/dependencies/           │
│    ├─ HarmonyImport…         │
│    ├─ CommonJsRequire…       │
│    ├─ Import…                │
│    └─ 115+ 种依赖类型         │
└──────────────────────────────┘
```

### 3.2 模块协作关系

```
用户代码
  ↓
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Compiler (控制器)
  ├─ 创建 Compilation
  ├─ 触发 make 钩子
  └─ 管理生命周期
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ↓
Compilation (执行器)
  ├─ addEntry ──→ 添加入口
  ├─ handleModuleCreation ──→ 创建模块
  │    │
  │    ├─→ NormalModuleFactory.create()
  │    │      └─ 解析路径 + 匹配 loader
  │    │
  │    ├─→ addModule()
  │    │      └─ 去重检查
  │    │
  │    ├─→ ModuleGraph.setResolvedModule() ⭐⭐⭐
  │    │      └─ 建立图连接
  │    │
  │    ├─→ buildModule()
  │    │      └─ NormalModule.build()
  │    │            └─ JavascriptParser.parse()
  │    │                  └─ 识别依赖
  │    │
  │    └─→ processModuleDependencies()
  │           └─ 递归处理依赖
  │
  └─ seal ──→ 优化和生成
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ↓
ModuleGraph (数据结构)
  ├─ 存储所有模块
  ├─ 存储所有连接
  └─ 提供查询接口
```

---

## 四、构建流程图（概览）

```
┌────────────────────────────────────────────────────────┐
│            依赖图构建主流程（< 60 节点）                │
└────────────────────────────────────────────────────────┘

[开始] webpack(config)
   ↓
[初始化] Compiler + Compilation
   ↓
[Make] compiler.hooks.make
   ↓
┌─────────────────────────┐
│ 步骤1: 添加入口          │
│ addEntry(entryDep)      │
└─────────────────────────┘
   ↓
┌─────────────────────────┐
│ 步骤2: 创建入口模块      │
│ factorizeModule()       │
│  ├─ resolve 路径        │
│  ├─ 匹配 loader         │
│  └─ new NormalModule()  │
└─────────────────────────┘
   ↓
┌─────────────────────────┐
│ 步骤3: 添加模块（去重）⭐│
│ addModule()             │
│  ├─ 检查已存在?         │
│  ├─ Yes → 返回现有      │
│  └─ No → 添加到集合     │
└─────────────────────────┘
   ↓
┌─────────────────────────────────┐
│ 步骤4: 构建模块 ⭐⭐⭐           │
│ module.build()                  │
│  ├─ 读取文件                    │
│  ├─ 执行 loader                 │
│  └─ parser.parse() → 收集依赖   │
└─────────────────────────────────┘
   ↓
┌─────────────────────────┐
│ 步骤5: 建立连接 ⭐⭐⭐   │
│ setResolvedModule()     │
│  ├─ 创建 Connection     │
│  ├─ 添加到 incoming     │
│  └─ 添加到 outgoing     │
└─────────────────────────┘
   ↓
┌─────────────────────────┐
│ 步骤6: 递归处理依赖 ⭐⭐⭐│
│ processModuleDeps()     │
│  └─ 对每个依赖递归执行   │
│      步骤2-6             │
└─────────────────────────┘
   ↓
   循环，直到无新依赖
   ↓
[完成] ModuleGraph 构建完成
```

---

## 五、详细流程图（分步骤）

### 流程图 1：AST 解析流程

```
JavascriptParser.parse() 详细流程

[输入] 源码字符串
   ↓
┌─────────────────────┐
│ acorn.parse(source) │
│  ↓生成 AST          │
└─────────────────────┘
   ↓
┌─────────────────────┐
│ detectMode()        │
│ 检测严格模式         │
└─────────────────────┘
   ↓
┌─────────────────────┐
│ preWalkStatements() │
│ 收集所有声明         │
│  ├─ import          │
│  ├─ export          │
│  ├─ var/let/const   │
│  └─ function/class  │
└─────────────────────┘
   ↓
┌─────────────────────┐
│ walkStatements()⭐⭐⭐│
│ 识别依赖            │
└─────────────────────┘
   │
   ├─→ import './a' → HarmonyImportDep
   ├─→ require('./b') → CommonJsRequireDep
   ├─→ import('./c') → ImportDep + AsyncBlock
   └─→ export → HarmonyExportDep
   ↓
[输出] module.dependencies = [...]
```

### 流程图 2：建立连接流程

```
setResolvedModule(origin, dep, target) 详细流程

[输入] origin=entry.js, dep=import './a', target=a.js
   ↓
┌─────────────────────────────────┐
│ 创建连接对象                     │
│ conn = new Connection(          │
│   origin, dep, target           │
│ )                               │
└─────────────────────────────────┘
   ↓
┌─────────────────────────────────┐
│ 添加到 target 的入边 ⭐          │
│ a.js.incoming.add(conn)         │
│                                 │
│ 效果: a.js 知道 entry 依赖它    │
└─────────────────────────────────┘
   ↓
┌─────────────────────────────────┐
│ 添加到 origin 的出边 ⭐          │
│ entry.js.outgoing.add(conn)     │
│                                 │
│ 效果: entry 知道它依赖 a.js     │
└─────────────────────────────────┘
   ↓
┌─────────────────────────────────┐
│ 建立映射 ⭐                      │
│ dependencyMap.set(dep, conn)    │
│                                 │
│ 效果: 可通过依赖找到连接         │
└─────────────────────────────────┘
   ↓
[完成] 双向连接建立
```

### 流程图 3：递归构建流程

```
递归构建示例（完整展开）

Entry
  ↓ addEntry
┌──────────────┐
│  entry.js    │ depth: 0
│  build()     │
│    ↓ parse   │
│  deps: [     │
│    './a.js', │ ←────┐
│    './b.js'  │      │
│  ]           │      │
└──────────────┘      │
  ↓ process           │
  ├───────┬───────┐   │
  │       │       │   │
  ↓       ↓       ↓   │
Level 1           │   │
┌────────┐ ┌────────┐│
│ a.js   │ │ b.js   ││
│ depth:1│ │ depth:1││
│ build()│ │ build()││
│   ↓    │ │   ↓    ││
│ deps:[共│ │ deps:[共│
│ './common'│ './common'
│ ]      │ │ ]      ││
└────────┘ └────────┘│
  ↓         ↓        │
  └────┬────┘        │
       ↓             │
Level 2              │
┌──────────┐         │
│common.js │         │
│ depth: 2 │ ←───────┘ 共享模块
│ build()  │
│   ↓      │
│ deps: [] │ 无依赖
└──────────┘
  ↓
结束

最终依赖图:
entry → a → common
  ↓     ↗
  b ───┘
```

---

## 六、构建算法详解

### 6.1 核心算法伪代码

```javascript
// 依赖图构建的递归算法
function buildGraph(entryDep) {
  // 1. 创建模块
  const module = factorize(entryDep);

  // 2. 去重
  const existingModule = addModule(module);
  if (existingModule !== module) {
    return existingModule;  // 模块已存在
  }

  // 3. 构建
  module.build();  // 收集 dependencies

  // 4. 建立连接 + 递归
  for (const dep of module.dependencies) {
    const depModule = factorize(dep);

    // ⭐⭐⭐ 核心：建立图连接
    moduleGraph.setResolvedModule(
      module, dep, depModule
    );

    // 递归构建
    buildGraph_recursive(depModule);
  }
}
```

### 6.2 去重机制

```javascript
// addModule 去重算法

┌────────────────────────────────┐
│ identifier = module.identifier()│
│ 格式: 'type|path'              │
│ 例如: 'javascript/auto|/a.js'  │
└────────────────────────────────┘
   ↓
┌────────────────────────────────┐
│ existing = _modules.get(id)    │
└────────────────────────────────┘
   ↓
  existing?
   ├─ Yes → return existing ⭐
   │         (复用已有模块)
   │
   └─ No → 继续
        ↓
     ┌────────────────────┐
     │ 尝试从缓存恢复      │
     └────────────────────┘
        ↓
     ┌────────────────────┐
     │ 添加到 _modules     │
     │ 添加到 modules      │
     └────────────────────┘
```

---

## 七、应用场景深入

### 7.1 Tree Shaking 详细流程

```
Tree Shaking 三阶段：

━━━━━━━ Make 阶段 ━━━━━━━

阶段1: 收集导出
  module.build()
    ↓ parser.parse()
  识别: export const foo = 1;
         export const bar = 2;
    ↓
  exportsInfo.setProvided(['foo', 'bar'])

阶段2: 记录使用
  dependency: import { foo } from './a'
    ↓
  dependency.getReferencedExports()
    ↓
  返回: [['foo']]  (只用 foo)

━━━━━━━ Seal 阶段 ━━━━━━━

阶段3: 标记使用状态
  FlagDependencyUsagePlugin
    ↓
  分析所有 dependency.referencedExports
    ↓
  exportsInfo.setUsed('foo', true)
  exportsInfo.setUsed('bar', false)

━━━━━━━ 代码生成 ━━━━━━━

阶段4: 删除未使用
  generator.generate()
    ↓
  if (exportsInfo.isUsed('foo')) {
    生成: __webpack_exports__.foo = 1; ✅
  }
  if (exportsInfo.isUsed('bar')) {
    跳过 ❌  // bar 未使用
  }

结果: 代码中只包含 foo
```

---

## 八、性能优化技巧

### 8.1 数据结构选择

| 场景 | 选择 | 原因 |
|------|------|------|
| 依赖→连接 | WeakMap | 不阻止 GC |
| 模块→节点 | Map | 需要遍历 |
| 连接集合 | SortableSet | 需要排序 |
| 跳过模块 | Set | 快速查找 |

### 8.2 优化技巧汇总

```javascript
// 1. 懒创建
_getModuleGraphModule(module) {
  let mgm = cache.get(module);
  if (!mgm) {
    mgm = new ModuleGraphModule();  // 需要时才创建
  }
  return mgm;
}

// 2. 三级缓存
// 超快路径 → 快路径 → 慢路径
// 99% → 0.9% → 0.1%

// 3. 缓存上次结果
let lastModule = null;
if (module === lastModule) {
  return cached;  // 直接用
}

// 4. WeakMap 避免泄漏
_dependencyMap: WeakMap  // 自动 GC

// 5. 去重机制
identifier 唯一标识
_modules.get(identifier)  // O(1) 查找
```

---

## 九、总结

### 核心要点

1. **数据结构**：
   - ModuleGraph：两个核心 Map
   - ModuleGraphModule：节点信息
   - ModuleGraphConnection：边信息

2. **构建算法**：
   - 递归遍历
   - 去重机制
   - 双向连接

3. **应用**：
   - Tree Shaking
   - 代码分割
   - 模块合并
   - 循环检测

4. **优化**：
   - WeakMap
   - 懒创建
   - 三级缓存
   - 去重

---

**已添加详细注释的文件**：
- lib/ModuleGraph.js（80%）
- lib/Dependency.js（100%）
- lib/Compilation.js（85%）
- lib/ModuleGraphConnection.js（计划中）
