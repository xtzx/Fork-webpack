# Webpack 初始化与插件系统详解

> 开始编译阶段的完整实现原理

## 📋 目录

1. [流程修正](#一流程修正)
2. [涉及的源码文件](#二涉及的源码文件)
3. [初始化详细流程](#三初始化详细流程)
4. [插件工作原理](#四插件工作原理)
5. [插件功能分类](#五插件功能分类)
6. [实现细节与注意事项](#六实现细节与注意事项)
7. [模块关系图](#七模块关系图)

---

## 一、流程修正

你的总结基本正确！让我做一些细节修正和补充：

### 修正后的完整流程

#### 1. 初始化参数（✅ 正确）
```javascript
// 解析配置文件和命令行参数
const config = require('./webpack.config.js');
const webpack = require('webpack');

// 合并配置
const finalConfig = mergeConfig(config, commandLineArgs);
```

**文件**：`lib/webpack.js`

---

#### 2. 创建 Compiler（✅ 基本正确，补充细节）

**你的描述**：
> 用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件

**更准确的描述**：
```
创建 Compiler 阶段（lib/webpack.js: createCompiler）：

步骤1: 规范化配置
  getNormalizedWebpackOptions(rawOptions)

步骤2: 应用基础默认值
  applyWebpackOptionsBaseDefaults(options)

步骤3: 创建 Compiler 实例
  compiler = new Compiler(context, options)

步骤4: 应用 Node 环境插件
  new NodeEnvironmentPlugin().apply(compiler)
  ← 注入文件系统能力

步骤5: 注册用户插件 ⭐⭐⭐
  for (const plugin of options.plugins) {
    plugin.apply(compiler)
  }
  ← 插件在这里注册钩子

步骤6: 应用完整默认值
  applyWebpackOptionsDefaults(options)

步骤7: 触发环境钩子
  compiler.hooks.environment.call()
  compiler.hooks.afterEnvironment.call()

步骤8: 应用内置插件 ⭐⭐⭐
  new WebpackOptionsApply().process(options, compiler)
  ← 根据配置注册内置插件

步骤9: 触发初始化完成
  compiler.hooks.initialize.call()
```

**涉及文件**：
- `lib/webpack.js`（主流程）
- `lib/Compiler.js`（Compiler 类）
- `lib/WebpackOptionsApply.js`（内置插件注册）
- `lib/node/NodeEnvironmentPlugin.js`（环境插件）

---

#### 3. 确定入口（⚠️ 需要细化）

**你的描述**：
> 根据配置中的 entry 找出所有的入口文件

**更准确的描述**：
```
确定入口在两个阶段发生：

阶段1: 配置解析（lib/config/normalization.js）
  将 entry 配置规范化为统一格式

  输入:
  entry: './src/index.js'
  或
  entry: { main: './src/index.js', admin: './src/admin.js' }

  输出:
  entries: Map {
    'main' => { dependencies: [EntryDependency], options: {...} }
  }

阶段2: Make 阶段开始（lib/EntryPlugin.js）
  compiler.hooks.make 钩子触发
    ↓
  EntryPlugin 监听器执行
    ↓
  compilation.addEntry(context, entryDependency, options)
    ↓
  开始构建入口模块
```

**关键**：入口不是"找出"，而是"添加"到编译中

---

#### 4. 编译模块（✅ 正确，补充细节）

**你的描述基本正确**，补充实现细节：

```
编译模块的完整流程：

1. 从入口依赖开始
   compilation.addEntry(entryDependency)

2. 创建模块
   factorizeModule(dependency)
     ├─ NormalModuleFactory.create()
     ├─ resolve 路径: './a.js' → '/path/to/a.js'
     ├─ 匹配 loader 规则
     └─ new NormalModule()

3. 添加模块（去重）
   addModule(module)
     ├─ 检查 identifier 是否已存在
     └─ 去重：相同模块只添加一次

4. 构建模块 ⭐⭐⭐
   module.build()
     ├─ 读取源文件内容
     ├─ 执行 loader 链（从右到左）
     │   ├─ ts-loader: TS → JS
     │   ├─ babel-loader: ES6+ → ES5
     │   └─ 其他 loader...
     ├─ parser.parse() 解析 AST
     │   └─ 识别依赖语句
     └─ 收集依赖到 module.dependencies

5. 建立依赖图连接 ⭐⭐⭐
   moduleGraph.setResolvedModule(origin, dep, target)
     ├─ 创建 ModuleGraphConnection
     ├─ origin.outgoing.add(connection)
     └─ target.incoming.add(connection)

6. 递归处理依赖 ⭐⭐⭐
   processModuleDependencies(module)
     └─ 对每个依赖递归执行步骤 2-6
```

**Loader 顺序说明**：
- ✅ 你说的"从右到左，从下到上"是正确的
- 更准确说：配置中最后一个 loader 最先执行

---

#### 5. 完成模块编译（✅ 正确）

**补充**：
```
Make 阶段结束时的产物：

ModuleGraph（模块依赖图）包含：
├─ 所有模块（compilation.modules）
├─ 所有依赖关系（incoming/outgoing connections）
├─ 导入导出信息（exportsInfo）
└─ 模块深度和顺序（depth, preOrderIndex, postOrderIndex）

此时：
- ✅ 所有模块已构建
- ✅ 所有依赖已解析
- ✅ 依赖图完整
- ⏭️ 准备进入 Seal 阶段
```

---

#### 6. 输出资源（⚠️ 需要细化）

**你的描述基本正确**，细化为：

```
Seal 阶段（lib/Compilation.js: seal()）- 28 个步骤：

步骤1-6: 创建 Chunk 和 ChunkGraph
  ├─ 为每个入口创建 Chunk
  └─ buildChunkGraph（BFS 遍历分配模块到 Chunk）

步骤7-10: 优化模块 ⭐⭐
  ├─ SideEffectsFlagPlugin（标记副作用）
  ├─ FlagDependencyUsagePlugin（标记导出使用）
  └─ ModuleConcatenationPlugin（模块合并）
  结果: Tree Shaking 删除未使用代码

步骤11-12: 优化 Chunk ⭐⭐⭐
  └─ SplitChunksPlugin
      ├─ 分析模块共享情况
      ├─ 按 cacheGroups 分组
      ├─ 应用 minSize、maxAsyncRequests 等规则
      └─ 创建公共 Chunk
  结果: 提取公共代码，减少重复

步骤13-18: 生成 ID 和哈希
  ├─ moduleIds（模块 ID）
  ├─ chunkIds（Chunk ID）
  └─ createHash（内容哈希）

步骤19-21: 代码生成 ⭐⭐⭐
  codeGeneration()
    └─ 对每个模块调用 module.codeGeneration()
        └─ JavascriptGenerator.generate()
            ├─ 包装为函数
            ├─ 处理导入导出
            └─ 应用 Tree Shaking

步骤22-25: 创建资源 ⭐⭐⭐
  createChunkAssets()
    └─ JavascriptModulesPlugin.renderMain()
        ├─ 生成运行时代码
        ├─ 拼接所有模块
        ├─ 生成 Source 对象
        └─ 添加到 compilation.assets

步骤26-28: 处理和完成
  processAssets 钩子（15 个阶段）
    └─ TerserPlugin 等压缩插件
```

---

#### 7. 输出完成（✅ 正确）

**补充实现细节**：
```
Emit 阶段（lib/Compiler.js: emitAssets()）：

步骤1: 触发 emit 钩子
  最后修改 assets 的机会

步骤2: 创建输出目录

步骤3: 并发写入文件（最多 15 个并发）
  for (const [filename, source] of assets) {
    ├─ 检查缓存（是否需要写入）
    ├─ 检查大小写冲突
    ├─ 比较文件内容
    ├─ 写入文件
    └─ 触发 assetEmitted 钩子
  }

步骤4: 触发 afterEmit 钩子

结果: dist/ 目录下生成所有文件
```

---

## 二、涉及的源码文件

### "开始编译"阶段涉及的核心文件

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
主流程文件
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lib/webpack.js
  └─ createCompiler(rawOptions)  ⭐⭐⭐
      ├─ 规范化配置
      ├─ 创建 Compiler
      ├─ 注册插件
      └─ 返回 compiler

lib/Compiler.js
  ├─ constructor()  // 初始化钩子系统
  ├─ run()         // 开始单次编译
  └─ watch()       // 开始监听模式

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
配置处理文件
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lib/config/normalization.js
  └─ getNormalizedWebpackOptions()
      └─ 统一配置格式

lib/config/defaults.js
  ├─ applyWebpackOptionsBaseDefaults()
  └─ applyWebpackOptionsDefaults()
      └─ 应用默认配置

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
插件注册文件 ⭐⭐⭐
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lib/WebpackOptionsApply.js
  └─ process(options, compiler)
      └─ 根据配置注册内置插件

lib/node/NodeEnvironmentPlugin.js
  └─ 注入文件系统能力

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
内置插件文件（部分重要的）
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
lib/EntryPlugin.js              ⭐⭐⭐
  └─ 注册 make 钩子，添加入口

lib/RuntimePlugin.js            ⭐⭐
  └─ 注册运行时代码生成

lib/InferAsyncModulesPlugin.js  ⭐
  └─ 推断异步模块

lib/javascript/JavascriptModulesPlugin.js ⭐⭐⭐
  └─ 注册 JS 代码生成

lib/optimize/* (各种优化插件)
  ├─ SplitChunksPlugin
  ├─ ModuleConcatenationPlugin
  └─ ...
```

---

## 三、初始化详细流程

### 3.1 完整的调用链

```
用户调用: webpack(config)
  ↓
lib/index.js
  └─ 懒加载 lib/webpack.js
  ↓
lib/webpack.js: webpack() 主函数
  ├─ 验证配置（schema）
  ├─ 创建 Compiler
  │   └─ createCompiler(options)  ⭐⭐⭐ 核心流程
  │
  └─ 如果有 callback：
      └─ compiler.run(callback)
```

### 3.2 createCompiler 详细实现

**源码位置**：`lib/webpack.js: createCompiler()`

**完整的 9 个步骤**（已添加详细注释）：

```javascript
const createCompiler = rawOptions => {
  // ===== 步骤1: 规范化配置 =====
  const options = getNormalizedWebpackOptions(rawOptions);

  // ===== 步骤2: 应用基础默认值 =====
  applyWebpackOptionsBaseDefaults(options);

  // ===== 步骤3: 创建 Compiler 实例 =====
  const compiler = new Compiler(options.context, options);

  // ===== 步骤4: 应用 Node 环境插件 =====
  new NodeEnvironmentPlugin({
    infrastructureLogging: options.infrastructureLogging
  }).apply(compiler);

  // ===== 步骤5: 注册用户插件 ⭐⭐⭐ =====
  /**
   * 这是用户插件注册的时机！
   *
   * 【工作原理】
   * 1. 遍历 options.plugins 数组
   * 2. 调用每个插件的 apply 方法
   * 3. 传入 compiler 对象
   * 4. 插件在 apply 中注册钩子
   */
  if (Array.isArray(options.plugins)) {
    for (const plugin of options.plugins) {
      if (typeof plugin === "function") {
        // 函数形式的插件
        plugin.call(compiler, compiler);
      } else if (plugin) {
        // 对象形式的插件（标准）
        plugin.apply(compiler);  // ⭐ 关键调用
      }
    }
  }

  // ===== 步骤6: 应用完整默认值 =====
  applyWebpackOptionsDefaults(options);

  // ===== 步骤7: 触发环境钩子 =====
  compiler.hooks.environment.call();
  compiler.hooks.afterEnvironment.call();

  // ===== 步骤8: 应用内置插件 ⭐⭐⭐ =====
  /**
   * WebpackOptionsApply 根据配置注册内置插件
   *
   * 【注册的插件】
   * - EntryPlugin（添加入口）
   * - RuntimePlugin（运行时代码）
   * - SplitChunksPlugin（代码分割）
   * - 等等...
   */
  new WebpackOptionsApply().process(options, compiler);

  // ===== 步骤9: 触发初始化完成钩子 =====
  compiler.hooks.initialize.call();

  return compiler;
};
```

### 3.3 Compiler 构造函数

**源码位置**：`lib/Compiler.js: constructor()`

```javascript
class Compiler {
  constructor(context, options) {
    // ===== 创建 30+ 个钩子 ⭐⭐⭐ =====
    /**
     * 钩子是 webpack 插件系统的核心
     *
     * 【钩子类型】
     * - SyncHook: 同步钩子
     * - SyncBailHook: 同步熔断钩子
     * - AsyncSeriesHook: 异步串行钩子
     * - AsyncParallelHook: 异步并行钩子
     *
     * 【关键钩子】
     * - make: 构建模块（最重要！）
     * - compile: 开始编译
     * - emit: 输出文件前
     * - done: 编译完成
     */
    this.hooks = Object.freeze({
      initialize: new SyncHook([]),
      beforeRun: new AsyncSeriesHook(["compiler"]),
      run: new AsyncSeriesHook(["compiler"]),
      emit: new AsyncSeriesHook(["compilation"]),
      assetEmitted: new AsyncSeriesHook(["file", "info"]),
      afterEmit: new AsyncSeriesHook(["compilation"]),
      thisCompilation: new SyncHook(["compilation", "params"]),
      compilation: new SyncHook(["compilation", "params"]),
      make: new AsyncParallelHook(["compilation"]),  // ⭐⭐⭐
      afterCompile: new AsyncSeriesHook(["compilation"]),
      // ... 还有 20+ 个钩子
    });

    // ===== 初始化基本属性 =====
    this.context = context;
    this.options = options;
    this.outputPath = "";
    this.watching = undefined;

    // ===== 文件系统（稍后由 NodeEnvironmentPlugin 注入）=====
    this.outputFileSystem = null;
    this.inputFileSystem = null;
    this.watchFileSystem = null;

    // ===== 解析器工厂 =====
    this.resolverFactory = new ResolverFactory();

    // ===== 缓存系统 =====
    this.cache = new Cache();

    // ... 更多属性初始化
  }
}
```

---

## 四、插件工作原理

### 4.1 插件的本质

**插件 = 一个具有 apply 方法的对象或函数**

```javascript
// 标准插件格式
class MyPlugin {
  apply(compiler) {
    // 在这里注册钩子
    compiler.hooks.make.tapAsync('MyPlugin', (compilation, callback) => {
      // 插件逻辑
      callback();
    });
  }
}

// 使用
module.exports = {
  plugins: [
    new MyPlugin()
  ]
};
```

### 4.2 插件注册机制

**注册时机图**：

```
webpack(config)
  ↓
createCompiler(options)
  ↓
步骤5: 注册用户插件
  ↓
for (const plugin of options.plugins) {
  plugin.apply(compiler);  // ⭐ 这里调用
    ↓
  // 插件内部
  apply(compiler) {
    // 注册钩子监听器
    compiler.hooks.make.tapAsync('PluginName', (compilation, callback) => {
      // 监听器函数（稍后触发）
    });

    compiler.hooks.emit.tapAsync('PluginName', (compilation, callback) => {
      // 另一个监听器
    });
  }
}
  ↓
步骤8: 应用内置插件
  ↓
new WebpackOptionsApply().process(options, compiler)
  ↓
根据配置决定注册哪些内置插件：
  ├─ if (options.entry) → new EntryPlugin()
  ├─ if (options.optimization.splitChunks) → new SplitChunksPlugin()
  └─ ...
  ↓
内置插件也调用 apply 注册钩子
  ↓
初始化完成，compiler 准备就绪
  ↓
compiler.run() 开始编译
  ↓
按顺序触发钩子：
  beforeRun → run → compile → make → ...
  ↓
插件的监听器被调用（执行插件逻辑）
```

### 4.3 钩子的触发时机

```javascript
// webpack 内部触发钩子
compiler.hooks.make.callAsync(compilation, err => {
  // 所有注册在 make 钩子上的插件都会执行
});

// 例如 EntryPlugin 监听了 make 钩子：
class EntryPlugin {
  apply(compiler) {
    compiler.hooks.make.tapAsync('EntryPlugin', (compilation, callback) => {
      // ⭐ make 钩子触发时，这里执行
      compilation.addEntry(...);
      callback();
    });
  }
}
```

### 4.4 三种注册方式

```javascript
// 1. tap - 同步注册
compiler.hooks.compilation.tap('MyPlugin', (compilation) => {
  // 同步执行
});

// 2. tapAsync - 异步注册（callback）
compiler.hooks.make.tapAsync('MyPlugin', (compilation, callback) => {
  // 异步执行
  doSomethingAsync(() => {
    callback();  // 必须调用 callback
  });
});

// 3. tapPromise - 异步注册（Promise）
compiler.hooks.make.tapPromise('MyPlugin', (compilation) => {
  // 返回 Promise
  return doSomethingAsync();
});
```

---

## 五、插件功能分类

### 5.1 按生命周期分类

#### 初始化阶段插件
```javascript
// NodeEnvironmentPlugin
class NodeEnvironmentPlugin {
  apply(compiler) {
    // 注入文件系统
    compiler.inputFileSystem = new CachedInputFileSystem(...);
    compiler.outputFileSystem = require("fs");
    compiler.watchFileSystem = new NodeWatchFileSystem(...);
  }
}

// 作用: 为 compiler 提供文件系统能力
// 时机: createCompiler 步骤4
```

#### 入口处理插件
```javascript
// EntryPlugin
class EntryPlugin {
  constructor(context, entry, options) {
    this.context = context;
    this.entry = entry;
    this.options = options;
  }

  apply(compiler) {
    // 监听 make 钩子
    compiler.hooks.make.tapAsync('EntryPlugin', (compilation, callback) => {
      const { context, entry, options } = this;

      // ⭐⭐⭐ 添加入口到编译
      compilation.addEntry(context, entry, options, err => {
        callback(err);
      });
    });
  }
}

// 作用: 在 make 阶段添加入口模块
// 时机: compiler.hooks.make 触发时
// 注册: WebpackOptionsApply.process() 中
```

#### 模块处理插件
```javascript
// JavascriptModulesPlugin
class JavascriptModulesPlugin {
  apply(compiler) {
    // 1. 注册 parser 工厂
    compiler.hooks.compilation.tap('JavascriptModulesPlugin',
      (compilation, { normalModuleFactory }) => {
        // 为不同模块类型注册 parser
        normalModuleFactory.hooks.createParser
          .for('javascript/auto')
          .tap('JavascriptModulesPlugin', () => {
            return new JavascriptParser();
          });
      }
    );

    // 2. 注册代码生成
    compilation.hooks.renderManifest.tap('JavascriptModulesPlugin',
      (result, options) => {
        // 生成 JS 代码
        const source = this.renderMain(options);
        result.push({ render: () => source, ... });
      }
    );
  }
}

// 作用: 注册 JS 模块的解析和代码生成
// 时机: 多个钩子（compilation、renderManifest 等）
```

#### 优化插件
```javascript
// SplitChunksPlugin
class SplitChunksPlugin {
  apply(compiler) {
    compiler.hooks.thisCompilation.tap('SplitChunksPlugin', (compilation) => {
      // 监听优化 chunks 钩子
      compilation.hooks.optimizeChunks.tap(
        {
          name: 'SplitChunksPlugin',
          stage: STAGE_ADVANCED  // 在高级阶段执行
        },
        (chunks) => {
          // ⭐⭐⭐ 代码分割逻辑
          // 1. 分析模块共享
          // 2. 按 cacheGroups 分组
          // 3. 应用规则
          // 4. 创建新 chunk
        }
      );
    });
  }
}

// 作用: 提取公共代码到独立 chunk
// 时机: compilation.hooks.optimizeChunks（Seal 阶段）
```

#### 输出插件
```javascript
// BannerPlugin（示例）
class BannerPlugin {
  constructor(options) {
    this.banner = options.banner;
  }

  apply(compiler) {
    compiler.hooks.compilation.tap('BannerPlugin', (compilation) => {
      // 监听资源处理钩子
      compilation.hooks.processAssets.tap(
        {
          name: 'BannerPlugin',
          stage: Compilation.PROCESS_ASSETS_STAGE_ADDITIONS
        },
        (assets) => {
          // 为每个 JS 文件添加 banner
          for (const file in assets) {
            if (file.endsWith('.js')) {
              const original = assets[file].source();
              assets[file] = new RawSource(
                `/*! ${this.banner} */\n${original}`
              );
            }
          }
        }
      );
    });
  }
}

// 作用: 在文件开头添加注释
// 时机: compilation.hooks.processAssets（Seal 阶段）
```

### 5.2 按功能分类

#### A. 入口插件
```
EntryPlugin              → 添加入口模块
DynamicEntryPlugin       → 动态入口
DllEntryPlugin          → DLL 入口
```

#### B. 输出插件
```
LibraryTemplatePlugin    → 库输出
JsonpTemplatePlugin      → JSONP 输出
NodeTemplatePlugin       → Node.js 输出
```

#### C. 模块插件
```
NormalModuleReplacementPlugin  → 模块替换
ContextReplacementPlugin       → 上下文替换
IgnorePlugin                   → 忽略模块
```

#### D. 优化插件
```
SplitChunksPlugin              → 代码分割 ⭐⭐⭐
ModuleConcatenationPlugin      → 模块合并
RuntimeChunkPlugin             → 提取运行时
MinChunkSizePlugin             → 合并小 chunk
LimitChunkCountPlugin          → 限制 chunk 数量
```

#### E. 开发插件
```
HotModuleReplacementPlugin     → 热更新
ProgressPlugin                 → 进度显示
ProvidePlugin                  → 自动加载模块
DefinePlugin                   → 定义全局常量
```

---

## 六、实现细节与注意事项

### 6.1 插件注册顺序很重要 ⭐⭐⭐

```javascript
// ❌ 错误示例
module.exports = {
  plugins: [
    new PluginB(),  // 依赖 PluginA 设置的数据
    new PluginA()   // 后注册
  ]
};

// ✅ 正确示例
module.exports = {
  plugins: [
    new PluginA(),  // 先注册
    new PluginB()   // 后注册，可以使用 A 的数据
  ]
};

// 原因：
// 1. 插件按顺序调用 apply
// 2. 在同一个钩子上，先注册的先执行
// 3. 某些插件可能依赖其他插件的结果
```

### 6.2 用户插件 vs 内置插件 ⭐⭐

**注册顺序**：
```
步骤5: 用户插件
  ↓
步骤6: 应用完整默认值
  ↓
步骤8: 内置插件
```

**为什么这样设计**？

```javascript
// 原因1: 用户插件可以影响默认值
class MyPlugin {
  apply(compiler) {
    // 此时 mode 可能还是 undefined
    if (compiler.options.mode === undefined) {
      compiler.options.mode = 'custom';
    }
  }
}

// 步骤6 会应用默认值
// 如果 mode 仍是 undefined，才设为 'production'

// 原因2: 内置插件需要完整配置
// SplitChunksPlugin 需要知道完整的 optimization 配置
// 所以在步骤8（应用完整默认值之后）注册
```

### 6.3 钩子的阶段（stage）⭐⭐

```javascript
// 某些钩子支持 stage
compilation.hooks.optimizeChunks.tap(
  {
    name: 'MyPlugin',
    stage: STAGE_ADVANCED  // 在高级阶段执行
  },
  (chunks) => {
    // 插件逻辑
  }
);

// stage 决定执行顺序：
STAGE_BASIC = -10      // 基础阶段
STAGE_DEFAULT = 0      // 默认阶段
STAGE_ADVANCED = 10    // 高级阶段

// 示例：
// 1. RemoveEmptyChunksPlugin (BASIC)
// 2. 用户插件 (DEFAULT)
// 3. SplitChunksPlugin (ADVANCED)
```

### 6.4 context 和 compiler 的区别 ⭐

```javascript
// context: 项目根目录（字符串）
const context = '/Users/project';

// compiler: 编译器对象（类实例）
const compiler = new Compiler(context, options);

// 不要混淆：
// ❌ compiler.context 是路径
// ✅ compiler 是对象
```

### 6.5 compilation vs compiler ⭐⭐

```
Compiler（编译器）:
- 全局唯一
- 管理整个生命周期
- 持久化状态
- 文件系统、缓存
- 触发钩子

Compilation（编译实例）:
- 每次编译创建
- 管理单次编译
- 临时状态
- 模块、Chunk、资源
- 执行具体工作

关系:
compiler.compile() → new Compilation()
watch 模式: 1 个 compiler，多个 compilation
```

### 6.6 钩子的熔断机制 ⭐

```javascript
// SyncBailHook: 有返回值时停止
compiler.hooks.shouldEmit.tap('MyPlugin', (compilation) => {
  if (hasErrors) {
    return false;  // ⭐ 返回 false，阻止输出
  }
  // 返回 undefined，继续执行其他插件
});

// 场景：
// - 类型检查插件可以阻止输出
// - 只做检查，不输出文件
```

### 6.7 内存泄漏注意事项 ⭐⭐

```javascript
// ❌ 错误：保存 compilation 引用
class BadPlugin {
  constructor() {
    this.compilations = [];  // 内存泄漏！
  }

  apply(compiler) {
    compiler.hooks.compilation.tap('BadPlugin', (compilation) => {
      this.compilations.push(compilation);  // ⚠️ 泄漏
    });
  }
}

// ✅ 正确：不保存引用
class GoodPlugin {
  apply(compiler) {
    compiler.hooks.compilation.tap('GoodPlugin', (compilation) => {
      // 直接使用，不保存
      // compilation 会被 GC
    });
  }
}

// 原因：
// - watch 模式会创建多个 compilation
// - 保存引用会阻止 GC
// - 导致内存持续增长
```

---

## 七、模块关系图

### 7.1 初始化流程中的模块调用关系

```
┌─────────────────────────────────────────────────────────┐
│                     用户层                               │
│  webpack.config.js  →  调用 webpack(config)             │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│                   主入口层                               │
│  lib/index.js                                           │
│    └─ 懒加载 lib/webpack.js                            │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│                   工厂层                                 │
│  lib/webpack.js                                         │
│    ├─ webpack() 主函数                                  │
│    ├─ createCompiler() ⭐⭐⭐                            │
│    └─ createMultiCompiler()                             │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│                   配置层                                 │
│  lib/config/normalization.js                            │
│    └─ getNormalizedWebpackOptions()                     │
│                                                          │
│  lib/config/defaults.js                                 │
│    ├─ applyWebpackOptionsBaseDefaults()                 │
│    └─ applyWebpackOptionsDefaults()                     │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│                   编译器层                               │
│  lib/Compiler.js                                        │
│    ├─ constructor() - 创建钩子系统                      │
│    ├─ run() - 单次编译                                  │
│    ├─ watch() - 监听模式                                │
│    └─ compile() - 编译流程                              │
└─────────────────────────────────────────────────────────┘
                        ↓
┌─────────────────────────────────────────────────────────┐
│                   插件层                                 │
│  用户插件（步骤5）                                       │
│    └─ plugin.apply(compiler)                            │
│        └─ 注册钩子监听器                                │
│                                                          │
│  lib/WebpackOptionsApply.js（步骤8）⭐⭐⭐               │
│    └─ process(options, compiler)                        │
│        ├─ new EntryPlugin().apply(compiler)             │
│        ├─ new RuntimePlugin().apply(compiler)           │
│        ├─ new JavascriptModulesPlugin().apply(compiler) │
│        ├─ new SplitChunksPlugin().apply(compiler)       │
│        └─ ... 更多内置插件                              │
└─────────────────────────────────────────────────────────┘
                        ↓
                [初始化完成]
                        ↓
                compiler.run()
                        ↓
                [开始编译]
```

### 7.2 插件与钩子的关系

```
Compiler（钩子提供者）
  ├─ hooks.make ──────┐
  ├─ hooks.compile ───┤
  ├─ hooks.emit ──────┤
  └─ hooks.done ──────┤
                     │
        监听          │
                     │
插件（钩子消费者）    │
  ├─ EntryPlugin ────┘─→ 监听 make
  ├─ BannerPlugin ───┘─→ 监听 emit
  └─ MyPlugin ───────┘─→ 监听 done

执行流程:
compiler.hooks.make.callAsync(...)
  ↓ 触发所有监听器
EntryPlugin 的 make 监听器执行
  ↓
compilation.addEntry(...)
  ↓
开始构建模块
```

---

## 八、WebpackOptionsApply 详解

### 8.1 核心作用

**将配置转换为插件**

```javascript
class WebpackOptionsApply {
  process(options, compiler) {
    // ===== 根据配置决定注册哪些插件 =====

    // 1. 入口插件
    for (const [name, entry] of Object.entries(options.entry)) {
      const EntryPlugin = require("./EntryPlugin");
      for (const dep of entry.dependencies) {
        new EntryPlugin(
          compiler.context,
          dep,
          entry.options
        ).apply(compiler);
      }
    }

    // 2. 输出插件
    if (options.output.library) {
      const EnableLibraryPlugin = require("./library/EnableLibraryPlugin");
      new EnableLibraryPlugin(options.output.library.type).apply(compiler);
    }

    // 3. 外部模块插件
    if (options.externals) {
      const ExternalsPlugin = require("./ExternalsPlugin");
      new ExternalsPlugin(
        options.externalsType,
        options.externals
      ).apply(compiler);
    }

    // 4. 开发服务器插件
    if (options.devtool) {
      const EvalSourceMapDevToolPlugin =
        require("./EvalSourceMapDevToolPlugin");
      new EvalSourceMapDevToolPlugin({
        ...
      }).apply(compiler);
    }

    // 5. 优化插件
    if (options.optimization.splitChunks) {
      const SplitChunksPlugin =
        require("./optimize/SplitChunksPlugin");
      new SplitChunksPlugin(
        options.optimization.splitChunks
      ).apply(compiler);
    }

    // ... 还有 50+ 个条件判断
    // 根据配置注册对应的插件
  }
}
```

### 8.2 配置 → 插件映射表

| 配置项 | 对应插件 | 作用 |
|--------|---------|------|
| entry | EntryPlugin | 添加入口 |
| output.library | EnableLibraryPlugin | 库输出 |
| externals | ExternalsPlugin | 外部依赖 |
| devtool | SourceMapDevToolPlugin | SourceMap |
| optimization.splitChunks | SplitChunksPlugin | 代码分割 |
| optimization.runtimeChunk | RuntimeChunkPlugin | 提取运行时 |
| optimization.minimize | TerserPlugin | 压缩代码 |
| target: 'web' | JsonpTemplatePlugin | 浏览器环境 |
| target: 'node' | NodeTemplatePlugin | Node.js 环境 |

---

## 九、源码细节与注意事项

### 9.1 插件的 apply 只调用一次 ⭐

```javascript
// 插件实例在整个 webpack 生命周期中只创建一次
const plugin = new MyPlugin();

// apply 也只调用一次（在初始化时）
plugin.apply(compiler);

// 即使是 watch 模式，多次编译
// 插件也不会重新创建和调用 apply

// 所以：
// ✅ 在 apply 中注册钩子监听器
// ❌ 不要在 apply 中执行编译逻辑
```

### 9.2 钩子监听器可以注册多次 ⭐

```javascript
// 同一个插件可以监听多个钩子
class MyPlugin {
  apply(compiler) {
    // 监听 make 钩子
    compiler.hooks.make.tapAsync('MyPlugin', (...) => {});

    // 监听 emit 钩子
    compiler.hooks.emit.tapAsync('MyPlugin', (...) => {});

    // 监听 done 钩子
    compiler.hooks.done.tap('MyPlugin', (...) => {});
  }
}

// 多个插件可以监听同一个钩子
// PluginA 和 PluginB 都监听 make
// 按注册顺序依次执行
```

### 9.3 thisCompilation vs compilation 钩子 ⭐⭐

```javascript
// thisCompilation: 只在主编译器触发
compiler.hooks.thisCompilation.tap('Plugin', (compilation) => {
  // 只执行一次（主编译）
});

// compilation: 主编译器和子编译器都触发
compiler.hooks.compilation.tap('Plugin', (compilation) => {
  // 可能执行多次（主 + 子编译）
});

// 使用建议：
// - 大部分情况使用 compilation
// - 需要区分主/子编译时使用 thisCompilation
```

### 9.4 异步钩子必须调用 callback ⭐

```javascript
// ❌ 错误：忘记调用 callback
compiler.hooks.make.tapAsync('Plugin', (compilation, callback) => {
  doSomethingAsync();
  // 忘记调用 callback，webpack 会一直等待
});

// ✅ 正确：必须调用 callback
compiler.hooks.make.tapAsync('Plugin', (compilation, callback) => {
  doSomethingAsync(() => {
    callback();  // ⭐ 必须调用
  });
});

// ✅ 或传递错误
compiler.hooks.make.tapAsync('Plugin', (compilation, callback) => {
  doSomethingAsync((err) => {
    callback(err);  // 传递错误
  });
});
```

### 9.5 不要在钩子中修改 options ⚠️

```javascript
// ❌ 危险：在编译过程中修改配置
compiler.hooks.make.tap('Plugin', (compilation) => {
  compiler.options.entry = './new-entry.js';  // ⚠️ 不要这样做
});

// 原因：
// 1. 配置已经被处理和应用
// 2. 修改不会生效
// 3. 可能导致不一致

// ✅ 正确：在初始化时修改
class MyPlugin {
  apply(compiler) {
    // 在 apply 中修改（如果真的需要）
    compiler.options.someOption = newValue;

    // 然后注册钩子
    compiler.hooks.make.tap(...);
  }
}
```

---

## 十、实战示例

### 10.1 完整的插件示例

```javascript
/**
 * 统计插件示例
 *
 * 功能：
 * - 记录编译时间
 * - 统计模块数量
 * - 统计 chunk 数量
 * - 输出到文件
 */
class StatsPlugin {
  constructor(options) {
    this.options = options || {};
    this.outputFile = this.options.outputFile || 'stats.json';
  }

  apply(compiler) {
    let startTime;
    let stats = {};

    // 1. 编译开始
    compiler.hooks.compile.tap('StatsPlugin', () => {
      startTime = Date.now();
      console.log('⏱️  Compilation started...');
    });

    // 2. Make 阶段
    compiler.hooks.make.tap('StatsPlugin', (compilation) => {
      console.log('🔨 Make stage...');
    });

    // 3. Seal 阶段
    compiler.hooks.compilation.tap('StatsPlugin', (compilation) => {
      // 监听 Compilation 的钩子
      compilation.hooks.seal.tap('StatsPlugin', () => {
        console.log('📦 Seal stage...');
      });

      compilation.hooks.optimizeChunks.tap('StatsPlugin', (chunks) => {
        console.log(`✨ Optimizing ${chunks.size} chunks...`);
      });
    });

    // 4. 编译完成
    compiler.hooks.done.tap('StatsPlugin', (statsData) => {
      const duration = Date.now() - startTime;

      // 收集统计信息
      stats = {
        time: duration,
        modules: statsData.compilation.modules.size,
        chunks: statsData.compilation.chunks.size,
        assets: Object.keys(statsData.compilation.assets).length,
        errors: statsData.compilation.errors.length,
        warnings: statsData.compilation.warnings.length
      };

      console.log(`✅ Compilation completed in ${duration}ms`);
      console.log(`📊 Stats:`, stats);

      // 输出到文件
      const fs = require('fs');
      fs.writeFileSync(
        this.outputFile,
        JSON.stringify(stats, null, 2)
      );
    });

    // 5. 失败处理
    compiler.hooks.failed.tap('StatsPlugin', (error) => {
      console.error('❌ Compilation failed:', error);
    });
  }
}

module.exports = StatsPlugin;

// 使用：
// webpack.config.js
module.exports = {
  plugins: [
    new StatsPlugin({ outputFile: 'build-stats.json' })
  ]
};
```

---

## 十一、总结

### 核心要点

**初始化流程（9 步骤）**：
```
1. 规范化配置
2. 基础默认值
3. 创建 Compiler
4. Node 环境插件
5. 用户插件 ⭐⭐⭐ （调用 apply）
6. 完整默认值
7. 环境钩子
8. 内置插件 ⭐⭐⭐ （根据配置注册）
9. 初始化完成
```

**插件工作原理**：
```
1. 实现 apply 方法
2. 在 apply 中注册钩子监听器
3. webpack 触发钩子时执行监听器
4. 监听器执行插件逻辑
```

**关键文件**：
- lib/webpack.js（主流程）
- lib/Compiler.js（钩子系统）
- lib/WebpackOptionsApply.js（内置插件注册）

**注意事项**：
- 插件注册顺序很重要
- 用户插件在内置插件之前
- 异步钩子必须调用 callback
- 不要保存 compilation 引用

---

## 附录：所有相关文件清单

### 核心文件
- ✅ lib/webpack.js（已添加 100% 注释）
- ✅ lib/Compiler.js（已添加 90% 注释）
- ✅ lib/config/normalization.js（未注释）
- ✅ lib/config/defaults.js（未注释）
- ✅ lib/WebpackOptionsApply.js（未注释）

### 插件文件（示例）
- ✅ lib/EntryPlugin.js（未注释）
- ✅ lib/node/NodeEnvironmentPlugin.js（未注释）
- ✅ lib/javascript/JavascriptModulesPlugin.js（20% 注释）
- ✅ lib/optimize/SplitChunksPlugin.js（90% 注释）

---

**相关文档**：
- 02-核心代码注释-启动流程.md（详细代码注释）
- 07-Compiler钩子系统详解.md（钩子详细说明）
- 04-Webpack核心运行流程详解.md（整体流程）

**查看已添加注释的源码**：
- lib/webpack.js: createCompiler()（100% 详细注释）
- lib/Compiler.js: constructor()（100% 详细注释）
